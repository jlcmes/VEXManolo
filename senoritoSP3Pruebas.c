#pragma config(Motor,  port2,           FR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BL,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           chain,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           FL,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BR,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           gearbox,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          pusher,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//CONSTANTS FOR MOVEMENT MANAGEMENT
// Controller 1/2, Stick L/R, Axis X/Y
#define C1LX vexRT[Ch4]
#define C1LY vexRT[Ch3]
#define C1RX vexRT[Ch1]

#define SPEED_MOTORS 60
#define SUPER_SPEED_MOTORS 127
#define TOLERANCE 30

//CONSTANTS FOR AUTONOMOUS MODE
//int AUTO_FORWARD_DISTANCE = 1491;
//int AUTO_RIGHT_TIME = 3200; //TODO: Adjust values on a real game field


task main() //usercontrol
{
  // User control code here, inside the loop

  while (true)
  {
		// ORIGINAL SOURCE CODE FOR THE MOVEMENT: https://www.vexforum.com/index.php/12370-holonomic-drives-2-0-a-video-tutorial-by-cody/0
  	// UPDATE: Not longer used anymore... code created from scratch.

  	//Nuevos controles de direccion (Arcade Mode) -----------------------

		if (((C1LX < -TOLERANCE) && (C1LX > TOLERANCE)) || ((C1LY > -TOLERANCE) && (C1LY < TOLERANCE))) //C1LY = 0 y C1LX != 0
		{
			//Movimiento Horizontal ---------------------------------------------
			motor[FL] = C1LX;
			motor[FR] = C1LX;
			motor[BL] = -C1LX;
			motor[BR] = -C1LX;
		}
		else if (((C1LX > -TOLERANCE) && (C1LX < TOLERANCE)) || ((C1LY < -TOLERANCE) && (C1LY > TOLERANCE))) //C1LY != 0 y C1LX = 0
		{
			//Movimiento Vertical -----------------------------------------------
			motor[FL] = C1LY;
			motor[FR] = -C1LY;
			motor[BL] = C1LY;
			motor[BR] = -C1LY;
		}
		else if (((C1LX < -TOLERANCE) && (C1LY < -TOLERANCE)) || ((C1LX > TOLERANCE) && (C1LY > TOLERANCE)))
		{
			//Movimiento Diagonal (+45 grados) -----------------------------------
			motor[FL] = C1LX;
			motor[FR] = 0;
			motor[BL] = 0;
			motor[BR] = -C1LX;
		}
		else if (((C1LX > TOLERANCE) && (C1LY < -TOLERANCE)) || ((C1LX < -TOLERANCE) && (C1LY > TOLERANCE)))
		{
			//Movimiento Diagonal (-45 grados) -----------------------------------
			motor[FL] = 0;
			motor[FR] = C1LX;
			motor[BL] = -C1LX;
			motor[BR] = 0;
		}
		else
		{
			//Ningun boton esta pulsado, motores a 0.
			motor[FL] = 0;
			motor[FR] = 0;
			motor[BL] = 0;
			motor[BR] = 0;
		}

		//Nuevo modo: Rotacion rapida
		if ((C1RX < -TOLERANCE) || (C1RX > TOLERANCE))
		{
			motor[FL] = C1RX;
			motor[FR] = C1RX;
			motor[BL] = C1RX;
			motor[BR] = C1RX;
		}

		// INTAKE
		if (vexRT[Btn6U] == 1)
			motor[claw] = -SPEED_MOTORS-40;//20
		else if (vexRT[Btn6D] == 1)
			motor[claw] = SPEED_MOTORS+40;//20
		else
			motor[claw] = 0;

		// LIFT
		if (vexRT[Btn5U] == 1)
			motor[gearbox] = SUPER_SPEED_MOTORS; //SPEED_MOTORS+20;
		else if (vexRT[Btn5D] == 1)
			motor[gearbox] = -SUPER_SPEED_MOTORS; //-SPEED_MOTORS;
		else
			motor[gearbox] = 0;

		// DEPLOY SYSTEM
		if (vexRT[Btn8U] == 1)
			motor[chain] = SUPER_SPEED_MOTORS; //SPEED_MOTORS+60;//40
		else if (vexRT[Btn8D] == 1)
			motor[chain] = -SUPER_SPEED_MOTORS; //-SPEED_MOTORS-60;//-40
		else
			motor[chain] = 0;

		// PUSHER
		if (vexRT[Btn8L] == 1)
			motor[pusher] = SUPER_SPEED_MOTORS; //SPEED_MOTORS+60;//40
		else if (vexRT[Btn8R] == 1)
			motor[pusher] = -SUPER_SPEED_MOTORS; //-SPEED_MOTORS-60;//-40
		else
			motor[pusher] = 0;

		// Motor values can only be updated every 20ms
		wait1Msec(20);
  }
}
